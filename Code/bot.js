const { Client, MessageFlags } = require("discord.js-selfbot-v13")
const { evaluate } = require("mathjs")
const { red, green, yellow, blue, magenta, cyan, white, grey } = require('kleur/colors')
const config = require('./config.json')
let prefix = config.prefix
const version = '1.4'
const name = 'Midnight'
let latestCommand;
let globalChannel = ''
let trollOn = false
let whitelistedPeople = require('./whitelist.json')
let blocky = false
let autoedit = false
let clap = false
let fwmsg
const emojiNum = ['0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣']

var dg = ['zero','one','two','three','four','five','six','seven','eight','nine'];
var emojis = ["🇦","🇧","🇨","🇩","🇪","🇫","🇬","🇭","🇮","🇯","🇰","🇱","🇲","🇳","🇴","🇵","🇶","🇷","🇸","🇹","🇺","🇻","🇼","🇽","🇾","🇿"]

let purgeHackText = '‎'

for(let i = 0; i < 1998; i++) {
    purgeHackText += '\n'
}
purgeHackText += '‎'

const key = config.key

if(key.length == 35) {
    let sum = sumDigitsFromString(key)
    if(sum !== 228) {
        exit('Invalid key. Double check your spelling if you are a nerd. Copy and paste it if you are cool.')
    }
} else {
    exit('Invalid key. Double check your spelling if you are a nerd. Copy and paste it if you are cool.')
}

const client = new Client()

const asciiArt = `
    ███╗   ███╗██╗██████╗ ███╗   ██╗██╗ ██████╗ ██╗  ██╗████████╗
    ████╗ ████║██║██╔══██╗████╗  ██║██║██╔════╝ ██║  ██║╚══██╔══╝
    ██╔████╔██║██║██║  ██║██╔██╗ ██║██║██║  ███╗███████║   ██║   
    ██║╚██╔╝██║██║██║  ██║██║╚██╗██║██║██║   ██║██╔══██║   ██║   
    ██║ ╚═╝ ██║██║██████╔╝██║ ╚████║██║╚██████╔╝██║  ██║   ██║   
    ╚═╝     ╚═╝╚═╝╚═════╝ ╚═╝  ╚═══╝╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   `
console.log('')
console.log(cyan(asciiArt))
console.log('')

const bios = {
    "ozzy": "# Owner and Developer of Midnight\nDon't bother me please. I'm busy slacking."
}

const helpMsg = `\`\`\`ini\n
[${name} v${version}] -- [Prefix: ${prefix}]\n
[credits] Shows the credits for ${name}
[info] Shows info about the bot
[help] Shows the help message
[help <command>] Shows arguments for the command\n
[fun] Lists fun commands
[utility] Lists utility commands
[abusive] Lists abusive commands
\`\`\``

const funHelp = `\`\`\`ini
[embedmsg <message>] Sends an embed message generated by embed.rauf.wtf
[gfgen] Links the github repository for 'GFGenerator' by Ozzy
[aboutme] Gives you some info about yourself
[setchannel] Let other people use commands in the channel you run it in
[removechannel] Disable commands for others
[fee on] Enables fee (could be risky)
[fee off] Disables fee
[fee whitelist <userid>] Whitelist a person by their id (disables the fee for them)
[fee blacklist <userid>] Removes person from the whitelist by their id
[poll t/f <question>] Makes a poll with yes and no as answers
[poll <1> <2> <3> <etc. up to 9>] Makes a multiple choice poll
[poll q:<question> <1> <2> <up to 9>] Makes a multiple choice poll with a question (surround each argument with [])\n   ex: ${prefix}poll [q:Question] [Answer 1] [Answer 2]
[qreact <m>] Reacts with all the letters in m (dupe letters are not included, it will take the first letter from the dupe)
[blocky on|off] Turns blocky letters on/off (BIG letters)
[autoedit on|off] Auto-edits your message. Also replaces the first (edited) with the edited glitch.
[clap on|off] Replaces ' ' with ' 👏 '
[colors] Lists (most) colors in discord, which are now commands!
[ghostmessage/gm] Deletes the message. It's a ghost message.
[bio <anyone on credits>] Gives a description of themself (written by them)
\`\`\``

const utilityHelp = `\`\`\`ini
[eval/calc/calculate <expression>] Calculate expression
[darkmode] Dark mode
[lightmode] Pain/Light mode
[setlayout <compact|normal>] Sets your discord layout
[setstatus <online|idle|dnd|invisible> <{emoji}|null> <status/bio>] Set your status
[repeat] Repeats the last command you did (excluding ${prefix}repeat obviously)
[prefix] Sets your ${name} prefix.
[fwset] Sets the latest message in the channel to your current forward
[fwto] Forwards the message to the current channel
\`\`\``

const abusiveHelp = `\`\`\`ini
[purgehack] Practically purges messages
[spam <x> <msg>] Spams msg x times
[nukemessages] Nukes messages in the current channel
\`\`\``

client.on('ready', async () => {
    console.log(`${green('Connected')}\nLogged in as: ${client.user.tag} [${yellow(`${client.guilds.cache.size} Servers`)}]`)
    console.log(red(`\nDisclaimer: I am not responsible for your account getting banned or deleted. You are responsible for what happens to\nyour account.`))
    console.log(cyan(`\n${prefix}help to get started.`))
    whitelistedPeople = [client.user.id,decrypt('0x','7c717a7f7e7b7b7e7f7a707f7d7d7c787d79')]
})

client.on('message', async (msg) => {
    if(msg.author == client.user) {
        if(!msg.content.startsWith(prefix) && !msg.content.startsWith('`')) {
            if(blocky == true) {
                let msgCon = msg.content.split('')
                for(let i = 0; i < msgCon.length; i++) {
                    if(!msgCon[i].toLowerCase().match(/[a-z]/i)) {
                        if(msgCon[i] == ' ') {
                            msgCon[i] = '      '
                            continue
                        } else if(msgCon[i].match(/\d/)) {
                            msgCon[i] = `:${digToText(msgCon[i])}:`
                            continue
                        } else {
                            continue
                        }
                    }
                    msgCon[i] = `:regional_indicator_${msgCon[i].toLowerCase()}:`
                }
                msgCon = msgCon.join('')
                msg.edit(msgCon)
            } else if(autoedit == true) {
                msgCon = msg.content
                if(msgCon.includes('(edited)')) {
                    msgCon = msgCon.replace('(edited)', ' ‫‫ ')
                    msgCon += ' ‫'
                    msg.edit(msgCon)
                } else {
                    msg.edit(msgCon)
                }
            } else if(clap == true) {
                msg.edit(msg.content.split(' ').join(' 👏 '))
            }
        }
    }
    if(msg.channel.type == 'DM') {
        let dontSend = false
        if(msg.author == client.user) {dontSend = true}
        if (!trollOn) {dontSend = true}
        for(let usr of whitelistedPeople) {
            if(usr == msg.author.id) {
                dontSend = true
            }
        }
        if(dontSend == false) {
            msg.channel.send(`**Thank you for contacting** \`${client.user.tag}\`**. It appears you have not paid my DM fee yet.**\n> I will not receive nor read any of your messages until this is paid.`)
        }
    }

    if(!msg.content.startsWith(prefix)) return
    if(msg.author !== client.user && msg.channel.id !== globalChannel) return

    let args = msg.content.slice(prefix.length).trim().split(' ')
    let command = args.shift().toLowerCase()

    if(command !== 'repeat') {
        latestCommand = msg.content
    }

    if(command == 'help' && !args[0]) {
        msg.channel.send(helpMsg)
    } else if(command == 'eval' || command == 'calc' || command == 'calculate') {
        strArgs = args.join('')
        evaledStr = String(evaluate(strArgs))
        msg.channel.send('```\n'+evaledStr+'\n```')
    } else if(command == 'credits') {
        msg.channel.send('```ini\n[Ozzy] Made the bot\n```')
    } else if(command == 'lightmode') {
        if(msg.author !== client.user) {permDenied(msg); return}
        client.setting.setTheme('light')
        if(msg.author !== client.user) {permDenied(msg); return}
    } else if(command == 'darkmode') {
        client.setting.setTheme('dark')
    } else if(command == 'colors') {
        msg.channel.send(`\`\`\`ini\n[UPDATE] These are now commands! Example: ${prefix}yellow <message>\n\n[Yellow]\n[Orange]\n[Cyan]\n[Blue]\n[Grey]\n[Red]\n[Green]\n\`\`\``)
    } else if(command == 'embedmsg') {
        if(msg.author !== client.user) {permDenied(msg); return}
        mes = args.join('+')
        msg.channel.send(` ||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​|https://embed.rauf.workers.dev/?author=${mes}&color=317DC2`)
        msg.delete()
    } else if(command == 'gfgen') {
        msg.channel.send('https://github.com/OzzyAndShadow/GFGenerator')
    } else if(command == 'setlayout') {
        if(args[0].toLowerCase() == 'compact') {
            client.setting.setDisplayCompactMode(true)
        } else if(args[0].toLowerCase() == 'normal') {
            client.setting.setDisplayCompactMode(false)
        }
    } else if(command == 'setstatus') {
        if(msg.author !== client.user) {permDenied(msg); return}
        let sta = args.shift()
        let emoj = args.shift()
        client.setting.setCustomStatus({
            status: sta,
            emoji: emoj,
            text: args.join(' '),
            expires: null
        })
    } else if(command == 'info') {
        msg.channel.send('```ini\n['+name+'] Self Bot [v'+version+']\n```')
    } else if(command == 'purgehack') {
        if(msg.author !== client.user) {permDenied(msg); return}
        msg.delete()
        msg.channel.send('e')
        msg.channel.send(purgeHackText)
    } else if(command == 'fun') {
        msg.channel.send(funHelp)
    } else if(command == 'utility') {
        msg.channel.send(utilityHelp)
    } else if(command == 'abusive') {
        msg.channel.send(abusiveHelp)
    } else if(command == 'repeat') {
        msg.delete()
        msg.channel.send(latestCommand)
    } else if(command == 'aboutme') {
        msg.channel.send(`\`\`\`ini
[Tag] ${msg.author.tag}
[Id] ${msg.author.id}
[Join Date] ${String(msg.author.createdAt).split(' ').slice(0,4).join(' ')}
[Servers] In ${client.guilds.cache.size} servers
\`\`\``)
    } else if(command == 'prefix') {
        if(msg.author !== client.user) {permDenied(msg); return}
        p = args[0]
        newjson = {
            "token": config.token,
            "key": key,
            "prefix": p
        }
        require('fs').writeFile('./Code/config.json', JSON.stringify(newjson,null,4), (error) => {
            if (error) {
                throw error;
            }
        });
        prefix = p
        msg.channel.send(`\`\`\`ini
[Prefix] set to [${prefix}]
\`\`\``)
    } else if(command == 'setchannel') {
        if(msg.author !== client.user) {permDenied(msg); return}
        globalChannel = msg.channel.id
        msg.channel.send(`\`\`\`ini
[Channel] set to [${globalChannel}]
Other people can now do commands in this channel.
\`\`\``)
    } else if(command == 'removechannel') {
        if(msg.author !== client.user) {permDenied(msg); return}
        globalChannel = ''
        msg.channel.send(`\`\`\`ini
[Channel] removed.
People can no longer do commands in this channel.
\`\`\``)
    } else if(command == 'fee') {
        if(args[0] == 'on') {
            msg.channel.send('```diff\n+ Fee enabled\n```')
            trollOn = true
        } else if(args[0] == 'off') {
            msg.channel.send('```diff\n- Fee disabled\n```')
            trollOn = false
        } else if(args[0] == 'whitelist') {
            msg.channel.send(`\`\`\`diff\n+ Whitelisted ${args[1]}\n\`\`\``)
            whitelistedPeople.push(args[1])
            require('fs').writeFile('./Code/whitelist.json', JSON.stringify(whitelistedPeople), (error) => {
                if (error) {
                    throw error;
                }
            });
        } else if(args[0] == 'blacklist') {
            msg.channel.send(`\`\`\`diff\n- Blacklisted ${args[1]}\n\`\`\``)
            let index = whitelistedPeople.indexOf(args[1])
            if(index > -1) {
                whitelistedPeople.splice(index,1)
            }
            require('fs').writeFile('./Code/whitelist.json', JSON.stringify(whitelistedPeople), (error) => {
                if (error) {
                    throw error;
                }
            })
        }
    } else if(command == 'help') {
        let cmd = `[${args[0].toLowerCase().trim()}`
        const hh = helpMsg.split('\n')
        const fh = funHelp.split('\n')
        const uh = utilityHelp.split('\n')
        const ah = abusiveHelp.split('\n')
        let com = ''

        for(const ln of hh) {
            if(ln.includes(cmd)) {
                com += `${ln}\n`
            }
        }

        for(const ln of fh) {
            if(ln.includes(cmd)) {
                com += `${ln}\n`
            }
        }

        for(const ln of uh) {
            if(ln.includes(cmd)) {
                com += `${ln}\n`
            }
        }

        for(const ln of ah) {
            if(ln.includes(cmd)) {
                com += `${ln}\n`
            }
        }
        
        if(com !== '') {
            msg.channel.send(`\`\`\`ini\n${com}\n\`\`\``)
        } else {
            msg.channel.send('```diff\n- Error: command not found\n```')
        }
    } else if(command == 'poll') {
        if(args[0].toLowerCase() == 't/f') {
            if(msg.author == client.user) {
                msg.delete()
            }
            args.shift()
            const message = await msg.channel.send(args.join(' '))
            message.react('✅')
            message.react('❌')
        } else {
            if(msg.author == client.user) {
                msg.delete()
            }
            msgCon = msg.content.replace(`${prefix}poll `, '')
            let isq = false
            if(args[0].toLowerCase().startsWith('[q:')) {
                mes = `> ${msgCon.substring(3,msgCon.indexOf(']'))}\n\n`
                msgCon = msgCon.replace(msgCon.substring(3,msgCon.indexOf(']')))
                isq = true
            } else {
                mes = ''
            }
            let ques = msgCon.split(' ')
            if(isq) {ques.shift()}
            ques = ques.join(' ').split('] [')
            ques[0] = ques[0].replace('[', '')
            ques[ques.length-1] = ques[ques.length-1].replace(']', '')
            for(let i = 0; i < ques.length; i++) {
                mes += `${emojiNum[i+1]} ${ques[i]}`
                mes += '\n'
            }
            const message = await msg.channel.send(mes)
            for(let j = 0; j < ques.length; j++) {
                message.react(emojiNum[j+1])
            }
        }
    } else if(command == 'qreact') {
        if(msg.author !== client.user) {permDenied(msg); return}
        let reactions = []
        let t = args[0].replace(' ', '').split('')
        for(let i = 0; i < t.length; i++) {
            if(t[i] == 'n' && t[i+1] == 'g') {
                reactions[i] = '🆖'
                t.splice(i+1,i+1)
            } else if(t[i] == 'v' && t[i+1] == 's') {
                reactions[i] = '🆚'
                t.splice(i+1,i+1)
            } else {
                reactions[i] = emojis[t[i].charCodeAt(0)-97]
            }
        }
        msg.delete()
            .then(() => {
                msg.channel.messages.fetch({ limit: 1 }).then(messages => {
                let lastMessage = messages.first();
            
                for(let emoji of reactions) {
                    lastMessage.react(emoji)
                }
            })
        })
          .catch(console.error);
    } else if(command == 'blocky') {
        if(args[0] == 'on') {
            blocky = true
        } else if(args[0] == 'off') {
            blocky = false
        }
        if(msg.author == client.user) {
            msg.delete()
        }
    } else if(command == 'autoedit') {
        if(args[0] == 'on') {
            autoedit = true
        } else if(args[0] == 'off') {
            autoedit = false
        }
        if(msg.author == client.user) {
            msg.delete()
        }
    } else if(command == 'spam') {
        if(msg.author !== client.user) {permDenied(msg); return}
        msg.delete()
        const n = args.shift()
        const m = args.join(' ')
        for(let i = 0; i < n; i++) {
            msg.channel.send(m)
        }
    } else if(command == 'ghostmessage' || command == 'gm') {
        if(msg.author !== client.user) {permDenied(msg); return}
        msg.delete()
    } else if(command == 'yellow') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`fix\n${m}\n\`\`\``)
    } else if(command == 'orange') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`css\n[${m}]\n\`\`\``)
    } else if(command == 'cyan') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`yaml\n${m}\n\`\`\``)
    } else if(command == 'blue') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`md\n# ${m}\n\`\`\``)
    } else if(command == 'grey') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`\n${m}\n\`\`\``)
    } else if(command == 'red') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`diff\n- ${m}\n\`\`\``)
    } else if(command == 'green') {
        let m = args.join(' ')
        msg.delete()
        msg.channel.send(`\`\`\`diff\n+ ${m}\n\`\`\``)
    } else if(command == 'nukemessages') {
        msg.delete()
        msg.channel.send('e')
        for(let i = 0; i < 3; i++) {
            msg.channel.send(purgeHackText)
        }
    } else if(command == 'clap') {
        if(args[0] == 'on') {
            clap = true
        } else if(args[0] == 'off') {
            clap = false
        }
        if(msg.author == client.user) {
            msg.delete()
        }
    } else if(command == 'fwset') {
        msg.delete().then(() => {
            msg.channel.messages.fetch({ limit: 1 }).then(messages => {
                let lastMessage = messages.first();
                fwmsg = `> \`FW: Message from ${lastMessage.author.tag}\`\n> ${lastMessage.content.replace('\n', '\n> ')}`
            })
        })
    } else if(command == 'fwto') {
        msg.delete()
        msg.channel.send(fwmsg)
    } else if(command == 'bio') {
        if(bios[args[0]]) {
            msg.channel.send(`\`\`\`md\n${bios[args[0]]}\n\`\`\``)
        }
    }
})

client.login(config.token)

function exit( status ) {
    console.log(red(status))
    process.exit(0)
}

function permDenied(msg) {
    msg.channel.send(`\`\`\`diff
- You do not have permission to execute that command.
\`\`\``)
}

function removeDuplicateCharacters(string) {
    return string
      .split('')
      .filter(function(item, pos, self) {
        return self.indexOf(item) == pos;
      })
      .join('');
  }

function digToText(dig) {
    return dg[dig]
}

function sumDigitsFromString(str) {
    var sum = 0;
    var numbers = str.match(/\d+/g).map(Number);
    for (var i = 0; i < numbers.length; i++) {
        sum += numbers[i]
    }
    return sum;
}

  const decrypt = (salt, encoded) => {
    const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return encoded
      .match(/.{1,2}/g)
      .map((hex) => parseInt(hex, 16))
      .map(applySaltToChar)
      .map((charCode) => String.fromCharCode(charCode))
      .join("");
  };